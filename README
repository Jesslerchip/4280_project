Storage=Global
### Jessica Seabolt CMP SCI 4280 Project Updated 05/10/2024 ###

Project 4: Code Generation

This C project implements a scanner, parser, and static semantics checker based on the provided lexical definitions and grammar. The scanner reads input from either standard input or a file and tokenizes the input according to the defined rules. The parser constructs a parse tree from the tokens generated by the scanner. The static semantics checker performs variable scope and usage enforcement on the parse tree. Finally, the program outputs a file (either file.asm or kb.asm) with our VM language equivalent of the submitted code.

Scanner Features

    Supports case-sensitive identifiers, keywords, operators, and integers
    Handles comments starting with "//"
    Reports scanner errors with line numbers and character counts
    Implemented using an FSA table and driver (getToken())

Parser Features

    Constructs a parse tree based on the provided grammar
    Supports the following constructs:
        Program structure (vars, tape, func, block)
        Variable declarations (with and without initialization)
        Arithmetic expressions
        Input/output statements (cin, cout)
        Conditional statements (if-then)
        Loops (while, repeat-until)
        Assignment statements
        Labels and goto statements
        Pick statements
    Reports parser errors with line numbers and character counts

Static Semantics Features

    Performs variable scope and usage enforcement on the parse tree
    Variables defined before the tape keyword are in the global scope, while variables inside any block or func are scoped within that block
    Checks for proper definition and use of variables
        Variables must be defined before being used for the first time
        Variable names can only be defined once in a scope but can be reused in another scope
    Reports static semantics errors with line numbers and character counts

Code Generation Features

    Has global storage for tracking variables
    Creates temporary variables and labels when needed
    Outputs VM assembly code to match the input

Files

    main.c: The main entry point of the program, processes command-line arguments, calls the parser and static semantics checker, and prints the parse tree
    scanner.c: Implementation of the scanner logic
    scanner.h: Header file for the scanner, containing function declarations and definitions
    parser.c: Implementation of the parser logic, now intertwined with code generation
    parser.h: Header file for the parser, containing function declarations and definitions
    token.h: Header file defining the token types and structures
    stack.c: Implementation of the stack data structure for variable scope tracking
    stack.h: Header file for the stack, containing function declarations and definitions

Usage

    To compile the project, use the provided Makefile by running the command:

        make

    To run the project, use the following command:

        ./compfs [file]


    If [file] is provided, the program will read input from the specified file.
    If no file is provided, the program will read input from standard input.

    Example Usage:

        ./compfs input.txt
        ./compfs < input.txt
        ./compfs

The scanner recognizes the following lexical elements:

    Identifiers: Begin with an uppercase or lowercase letter and can contain letters, underscores, or digits.
    Keywords: start, stop, while, repeat, until, label, return, cin, cout, tape, jump, if, then, pick, create, set, func.
    Operators and delimiters: =, <, >, ==, =!=, :, :=, +, -, *, /, ^, ., (, ), ,, {, }, ;, [, ], ||, &&, ...
    Integers: Any sequence of decimal digits, no sign, no decimal point.
    Comments: Start with "//" and turn the rest of the line into a comment.

The scanner reports errors for any unrecognized characters or tokens that exceed the maximum length (currently 256).

The parser constructs a parse tree based on the provided grammar. It reports parser errors with line numbers and character counts. The parse tree is no longer printed.

The static semantics checker performs variable scope and usage enforcement on the parse tree. It checks for proper definition and use of variables, ensuring that variables are defined before being used and that variable names are unique within a scope. The static semantics checker reports errors with line numbers and character counts.

There should be no output in the terminal unless there is an error. The program will produce a file named file.asm or kb.asm, depending on if you used a file or the terminal as an input method.